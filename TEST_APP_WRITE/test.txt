Under  normal circumstances every Unix program has three streams opened for it when it starts up, one for input, one for output, and one for printing diagnostic or error messages. These are typically attached to  the  user’sterminal  (see  tty(4)  but  might instead refer to files or other devices, depending on what the parent process chose to set up.  (See also the "Redirection" section of sh(1). The input stream is referred to as "standard input"; the output stream is referred to as "standard output";  and the  error  stream  is referred to as "standard error".  These terms are abbreviated to form the symbols used to refer to these files, namely stdin, stdout, and stderr. Each of these symbols is a stdio(3) macro of type  pointer  to  FILE, and  can  be  used  with  functions  like       fprintf(3) or fread(3). Since FILEs are a buffering wrapper around Unix file descriptors, the same underlying files may also be accessed using the raw Unix file interface, that is, the functions like read(2) and lseek(2). On program startup, the integer file descriptors associated with the streams stdin, stdout, and stderr are 0, 1, and  2,  respectively.  The preprocessor symbols STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO are defined with these values in <unistd.h>.  (Applying freopen(3) to one of these streams can change the file descriptor  number associated with the stream.) Note  that  mixing  use of FILEs and raw file descriptors can produce unexpected results and should generally be avoided.  (For the masochistic among you: POSIX.1, section 8.2.3, describes in detail how  this  interaction  is supposed  to  work.)   A  general rule is that file descriptors are handled in the kernel, while stdio is just alibrary.  This means for example, that after an exec(3), the child inherits all open file descriptors,  but  all old streams have become inaccessible. Since  the symbols stdin, stdout, and stderr are specified to be macros, assigning to them is non-portable.  The standard streams can be made to refer to different files with help of the library function freopen(3), specially introduced to make it possible to reassign stdin, stdout, and stderr. The standard streams are closed by a call to exit(3) and by normal program termination The protocol specifies a particular protocol to be used with the socket.  Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be  specified  as 0.  However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner.  The protocol number to use is specific to the “communication domain” in which communication  i   take place; see protocols(5).  See getprotoent(3) on how to map protocol name strings to protocol numbers. Sockets  of type SOCK_STREAM are full-duplex byte streams, similar to pipes.  They do not preserve record bound-aries.  A stream socket must be in a connected state before any data may be sent or received on it.   A  connection to another socket is created with a connect(2) call.  Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls. When  a  session  has  been  completed  a close(2)  may  be  performed.   Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2). The communications protocols which implement a SOCK_STREAM ensure that data is not lost  or  duplicated.   If a piece  of  data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is considered to be dead. When SO_KEEPALIVE is enabled on  the  socket the  protocol  checks in a protocol-specific manner if the other end is still alive.  A SIGPIPE signal is raised if a process sends or receives on a broken stream; this causes naive processes, which do not handle the  signal, to  exit.   SOCK_SEQPACKET  sockets employ the same system calls as SOCK_STREAM sockets.  The only difference is that read(2) calls will return only the amount of data requested, and any data remaining in the arriving  packet will be discarded.  Also all message boundaries in incoming datagrams are preserved. SOCK_DGRAM  and  SOCK_RAW  sockets allow sending of datagrams to correspondents named in sendto(2) calls.  Data- grams are generally received with recvfrom(2), which returns the next datagram along with  the  address  of  its sender. SOCK_PACKET  is  an  obsolete socket type to receive raw packets directly from the device driver.  Use packet(7) instead. An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a SIGURG signal when the  out-of-band  data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly.  This operation may also be used to set the process or process group that receives the I/O and asynchronous notification of I/O  events  via  SIGIO.  Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP argument. When the network signals an error condition to the protocol module (e.g., using a ICMP message for IP) the pending error flag is set for the socket.  The next operation on this socket will return the error code of the pending error.  For some protocols it is possible to enable a per-socket error queue to retrieve  detailed  information about the error; see IP_RECVERR in ip(7).The  operation  of  sockets is controlled by socket level options. These options are defined in <sys/socket.h>. The functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively
